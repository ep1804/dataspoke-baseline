---
# ConfigMap: injects the lock service Python script into the container.
# Pure stdlib — no pip install required.

apiVersion: v1
kind: ConfigMap
metadata:
  name: dev-lock-script
  labels:
    app: dev-lock
data:
  lock_service.py: |
    #!/usr/bin/env python3
    """DataSpoke dev-env lock service — pure stdlib, no dependencies."""
    import json
    import os
    import threading
    from datetime import datetime, timezone
    from http.server import BaseHTTPRequestHandler, HTTPServer

    _lock = threading.Lock()
    _state = {"owner": None, "acquired_at": None, "message": None}


    def _now_iso():
        return datetime.now(timezone.utc).isoformat(timespec="seconds")


    class LockHandler(BaseHTTPRequestHandler):
        def log_message(self, fmt, *args):
            pass  # silence default access log

        def _send_json(self, status, body):
            payload = json.dumps(body, indent=2).encode()
            self.send_response(status)
            self.send_header("Content-Type", "application/json")
            self.send_header("Content-Length", str(len(payload)))
            self.end_headers()
            self.wfile.write(payload)

        def _read_body(self):
            length = int(self.headers.get("Content-Length", 0))
            return json.loads(self.rfile.read(length)) if length else {}

        def do_GET(self):
            path = self.path.rstrip("/") or "/"
            if path == "/health":
                self._send_json(200, {"status": "ok"})
            elif path in ("/lock", "/"):
                with _lock:
                    snap = dict(_state)
                snap["locked"] = snap["owner"] is not None
                self._send_json(200, snap)
            else:
                self._send_json(404, {"error": "not found"})

        def do_POST(self):
            path = self.path.rstrip("/")
            body = self._read_body()
            if path == "/lock/acquire":
                owner = (body.get("owner") or "").strip()
                if not owner:
                    self._send_json(400, {"error": "'owner' field is required"})
                    return
                with _lock:
                    if _state["owner"] is not None:
                        self._send_json(409, {
                            "error": "already locked",
                            "owner": _state["owner"],
                            "acquired_at": _state["acquired_at"],
                            "message": _state["message"],
                        })
                        return
                    _state["owner"] = owner
                    _state["acquired_at"] = _now_iso()
                    _state["message"] = (body.get("message") or "").strip()
                    snap = dict(_state)
                snap["locked"] = True
                self._send_json(200, snap)
            elif path == "/lock/release":
                owner = (body.get("owner") or "").strip()
                with _lock:
                    if _state["owner"] is None:
                        self._send_json(200, {"locked": False, "message": "already unlocked"})
                        return
                    if owner and _state["owner"] != owner:
                        self._send_json(403, {
                            "error": "not the lock owner",
                            "current_owner": _state["owner"],
                        })
                        return
                    _state["owner"] = None
                    _state["acquired_at"] = None
                    _state["message"] = None
                self._send_json(200, {"locked": False, "message": "released"})
            else:
                self._send_json(404, {"error": "not found"})

        def do_DELETE(self):
            path = self.path.rstrip("/")
            if path == "/lock":
                with _lock:
                    _state["owner"] = None
                    _state["acquired_at"] = None
                    _state["message"] = None
                self._send_json(200, {"locked": False, "message": "force-released"})
            else:
                self._send_json(404, {"error": "not found"})


    if __name__ == "__main__":
        port = int(os.environ.get("LOCK_SERVICE_PORT", 8080))
        server = HTTPServer(("0.0.0.0", port), LockHandler)
        print(f"Lock service listening on port {port}", flush=True)
        server.serve_forever()

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: dev-lock
  labels:
    app: dev-lock
spec:
  replicas: 1
  selector:
    matchLabels:
      app: dev-lock
  template:
    metadata:
      labels:
        app: dev-lock
    spec:
      containers:
        - name: lock
          image: python:3.12-slim
          command: ["python", "/app/lock_service.py"]
          ports:
            - containerPort: 8080
              name: http
          env:
            - name: LOCK_SERVICE_PORT
              value: "8080"
          resources:
            requests:
              cpu: "10m"
              memory: "32Mi"
            limits:
              cpu: "100m"
              memory: "64Mi"
          volumeMounts:
            - name: script
              mountPath: /app
          livenessProbe:
            httpGet:
              path: /health
              port: 8080
            initialDelaySeconds: 5
            periodSeconds: 10
          readinessProbe:
            httpGet:
              path: /health
              port: 8080
            initialDelaySeconds: 3
            periodSeconds: 5
      volumes:
        - name: script
          configMap:
            name: dev-lock-script

---
apiVersion: v1
kind: Service
metadata:
  name: dev-lock
  labels:
    app: dev-lock
spec:
  type: ClusterIP
  selector:
    app: dev-lock
  ports:
    - name: http
      port: 8080
      targetPort: 8080
      protocol: TCP
