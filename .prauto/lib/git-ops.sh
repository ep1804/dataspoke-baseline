# Git and PR lifecycle operations for prauto.
# Source this file — do not execute directly.
# Requires: helpers.sh sourced, config loaded, gh/git available.

# Create a new worktree on a fresh branch from the base.
# If the branch already exists (retry scenario), reuses it in a new worktree.
# Usage: create_branch <issue_number>
# Sets: BRANCH_NAME, WORKTREE_DIR
create_branch() {
  local issue_number="$1"
  BRANCH_NAME="${PRAUTO_BRANCH_PREFIX}I-${issue_number}"
  WORKTREE_DIR="${PRAUTO_DIR}/worktrees/I-${issue_number}"

  info "Fetching from origin..."
  git fetch origin 2>/dev/null || warn "git fetch failed — continuing with local refs."

  # Remove stale worktree from a previous attempt.
  if [[ -d "$WORKTREE_DIR" ]]; then
    warn "Removing stale worktree at ${WORKTREE_DIR}."
    git worktree remove --force "$WORKTREE_DIR" 2>/dev/null || rm -rf "$WORKTREE_DIR"
    git worktree prune 2>/dev/null || true
  fi

  if git show-ref --verify --quiet "refs/remotes/origin/${BRANCH_NAME}" ||
     git show-ref --verify --quiet "refs/heads/${BRANCH_NAME}"; then
    info "Branch ${BRANCH_NAME} already exists. Reusing in new worktree."
    git worktree add "$WORKTREE_DIR" "$BRANCH_NAME" 2>/dev/null ||
      error "Failed to create worktree for ${BRANCH_NAME}."
  else
    info "Creating branch ${BRANCH_NAME} from origin/${PRAUTO_BASE_BRANCH}..."
    git worktree add -b "$BRANCH_NAME" "$WORKTREE_DIR" "origin/${PRAUTO_BASE_BRANCH}" 2>/dev/null ||
      error "Failed to create worktree for new branch ${BRANCH_NAME}."
  fi

  info "Worktree ready at ${WORKTREE_DIR} (branch: ${BRANCH_NAME})."
}

# Create a worktree for an existing remote branch (resume or PR review).
# Usage: checkout_branch_worktree <branch_name>
# Sets: WORKTREE_DIR
checkout_branch_worktree() {
  local branch="$1"
  local safe_name="${branch//\//-}"
  WORKTREE_DIR="${PRAUTO_DIR}/worktrees/${safe_name}"

  info "Fetching origin/${branch}..."
  git fetch origin "$branch" 2>/dev/null || warn "git fetch failed for ${branch}."

  if [[ -d "$WORKTREE_DIR" ]]; then
    warn "Removing stale worktree at ${WORKTREE_DIR}."
    git worktree remove --force "$WORKTREE_DIR" 2>/dev/null || rm -rf "$WORKTREE_DIR"
    git worktree prune 2>/dev/null || true
  fi

  git worktree add "$WORKTREE_DIR" "$branch" 2>/dev/null ||
    error "Failed to create worktree for branch ${branch}."

  info "Worktree ready at ${WORKTREE_DIR} (branch: ${branch})."
}

# Push the current branch to origin.
push_branch() {
  local branch="$1"
  info "Pushing ${branch} to origin..."
  git push -u origin "$branch" 2>/dev/null || error "Failed to push ${branch} to origin."
  info "Pushed ${branch}."
}

# Create or update a PR for the given issue.
# Usage: create_or_update_pr <issue_number> <issue_title> <branch>
create_or_update_pr() {
  local issue_number="$1"
  local issue_title="$2"
  local branch="$3"

  # Check for existing PR
  local existing_pr
  existing_pr=$(gh pr list \
    -R "$PRAUTO_GITHUB_REPO" \
    --head "$branch" \
    --json number \
    --jq '.[0].number // empty' 2>/dev/null)

  if [[ -n "$existing_pr" ]]; then
    info "PR #${existing_pr} already exists for ${branch}. Adding update comment."
    local commit_log
    commit_log=$(git log --oneline "origin/${PRAUTO_BASE_BRANCH}..HEAD" 2>/dev/null || echo "(no commits)")
    gh pr comment "$existing_pr" -R "$PRAUTO_GITHUB_REPO" \
      --body "prauto(${PRAUTO_WORKER_ID}): Updated with new commits.

\`\`\`
${commit_log}
\`\`\`" 2>/dev/null || warn "Failed to comment on PR #${existing_pr}."
    return 0
  fi

  # Generate PR body
  local commit_log
  commit_log=$(git log --oneline "origin/${PRAUTO_BASE_BRANCH}..HEAD" 2>/dev/null || echo "(no commits)")

  local pr_body
  pr_body="## Summary

Automated implementation for #${issue_number}.
Generated by \`prauto(${PRAUTO_WORKER_ID})\` using Claude Code CLI.

## Changes

\`\`\`
${commit_log}
\`\`\`

## Test plan

- [ ] Review automated changes
- [ ] Verify tests pass in CI
- [ ] Check spec compliance

---
*Generated by prauto -- autonomous PR worker*"

  local repo_owner="${PRAUTO_GITHUB_REPO%%/*}"

  info "Creating PR for issue #${issue_number}..."
  gh pr create \
    -R "$PRAUTO_GITHUB_REPO" \
    --base "$PRAUTO_BASE_BRANCH" \
    --head "$branch" \
    --title "prauto: ${issue_title}" \
    --body "$pr_body" \
    --assignee "${PRAUTO_GITHUB_ACTOR}" \
    --reviewer "${repo_owner}" 2>/dev/null || error "Failed to create PR for ${branch}."

  info "PR created for issue #${issue_number}."
}

# Find open PRs with unaddressed reviewer comments.
# Sets: ACTIONABLE_PR_NUMBER, ACTIONABLE_PR_BRANCH, ACTIONABLE_PR_ISSUE, ACTIONABLE_COMMENTS
# Returns 0 if found, 1 if none.
find_actionable_prs() {
  local prs_json
  prs_json=$(gh pr list \
    -R "$PRAUTO_GITHUB_REPO" \
    --state open \
    --json number,headRefName,reviews \
    --limit 50 2>/dev/null) || {
    warn "Failed to list PRs."
    return 1
  }

  # Filter PRs on prauto branches
  local prauto_prs
  prauto_prs=$(echo "$prs_json" | jq -r --arg prefix "$PRAUTO_BRANCH_PREFIX" '
    [.[] | select(.headRefName | startswith($prefix))]
    | sort_by(.number)
  ')

  local pr_count
  pr_count=$(echo "$prauto_prs" | jq 'length')

  if [[ "$pr_count" -eq 0 ]]; then
    return 1
  fi

  # Check each PR for unaddressed reviewer comments
  local i=0
  while [[ "$i" -lt "$pr_count" ]]; do
    local pr_number
    pr_number=$(echo "$prauto_prs" | jq -r ".[$i].number")
    local pr_branch
    pr_branch=$(echo "$prauto_prs" | jq -r ".[$i].headRefName")

    # Get review comments (changes requested)
    local reviews
    reviews=$(gh pr view "$pr_number" -R "$PRAUTO_GITHUB_REPO" \
      --json reviews \
      --jq '[.reviews[] | select(.state == "CHANGES_REQUESTED" or .state == "COMMENTED")] | sort_by(.submittedAt) | last' \
      2>/dev/null)

    # Get PR comments to check for prauto replies
    local pr_comments
    pr_comments=$(gh api "repos/${PRAUTO_GITHUB_REPO}/pulls/${pr_number}/comments" \
      --jq '[.[] | {id: .id, body: .body, user: .user.login, created_at: .created_at}]' \
      2>/dev/null || echo "[]")

    # Find comments not yet addressed by prauto
    local unaddressed
    unaddressed=$(echo "$pr_comments" | jq -r --arg worker "prauto(${PRAUTO_WORKER_ID})" '
      [.[] | select(.body | startswith($worker) | not)]
    ')

    local unaddressed_count
    unaddressed_count=$(echo "$unaddressed" | jq 'length')

    if [[ "$unaddressed_count" -gt 0 ]] && [[ -n "$reviews" ]] && [[ "$reviews" != "null" ]]; then
      ACTIONABLE_PR_NUMBER="$pr_number"
      ACTIONABLE_PR_BRANCH="$pr_branch"
      # Extract issue number from branch name (prauto/I-42 → 42)
      ACTIONABLE_PR_ISSUE="${pr_branch#${PRAUTO_BRANCH_PREFIX}I-}"
      ACTIONABLE_COMMENTS=$(echo "$pr_comments" | jq -r --arg worker "prauto(${PRAUTO_WORKER_ID})" '
        [.[] | select(.body | startswith($worker) | not)]
        | map("Comment #\(.id) by \(.user):\n\(.body)")
        | join("\n\n---\n\n")
      ')
      info "Found actionable PR #${pr_number} with unaddressed comments."
      return 0
    fi

    i=$((i + 1))
  done

  return 1
}

# Find prauto-owned PRs that are approved by the repo owner and merge-ready.
# Sets: MERGEABLE_PR_NUMBER, MERGEABLE_PR_BRANCH, MERGEABLE_PR_TITLE,
#       MERGEABLE_PR_BODY, MERGEABLE_PR_ISSUE
# Returns 0 if found, 1 if none.
find_mergeable_prs() {
  local repo_owner="${PRAUTO_GITHUB_REPO%%/*}"
  local prs_json
  prs_json=$(gh pr list -R "$PRAUTO_GITHUB_REPO" --state open \
    --json number,headRefName,title,body --limit 50 2>/dev/null) || {
    warn "Failed to list PRs for merge check."
    return 1
  }

  local pr_numbers
  pr_numbers=$(echo "$prs_json" | jq -r --arg prefix "$PRAUTO_BRANCH_PREFIX" '
    [.[] | select(.headRefName | startswith($prefix))]
    | sort_by(.number) | .[].number')
  [[ -z "$pr_numbers" ]] && return 1

  while IFS= read -r pr_number; do
    [[ -z "$pr_number" ]] && continue
    local pr_branch pr_title pr_body
    pr_branch=$(echo "$prs_json" | jq -r --argjson n "$pr_number" '.[] | select(.number==$n) | .headRefName')
    pr_title=$(echo "$prs_json"  | jq -r --argjson n "$pr_number" '.[] | select(.number==$n) | .title')
    pr_body=$(echo "$prs_json"   | jq -r --argjson n "$pr_number" '.[] | select(.number==$n) | .body // ""')

    local pr_detail
    pr_detail=$(gh pr view "$pr_number" -R "$PRAUTO_GITHUB_REPO" \
      --json mergeable,mergeStateStatus,reviews 2>/dev/null) || continue

    local mergeable merge_state
    mergeable=$(echo "$pr_detail"    | jq -r '.mergeable')
    merge_state=$(echo "$pr_detail"  | jq -r '.mergeStateStatus')

    local is_approved
    is_approved=$(echo "$pr_detail" | jq -r --arg owner "$repo_owner" '
      (.reviews // [])
      | map(select(.author.login == $owner))
      | sort_by(.submittedAt)
      | last // {}
      | .state == "APPROVED"')

    if [[ "$is_approved" == "true" ]] && \
       [[ "$mergeable" == "MERGEABLE" ]] && \
       [[ "$merge_state" == "CLEAN" ]]; then
      MERGEABLE_PR_NUMBER="$pr_number"
      MERGEABLE_PR_BRANCH="$pr_branch"
      MERGEABLE_PR_TITLE="$pr_title"
      MERGEABLE_PR_BODY="$pr_body"
      MERGEABLE_PR_ISSUE="${pr_branch#${PRAUTO_BRANCH_PREFIX}I-}"
      info "Found merge-ready PR #${pr_number} approved by ${repo_owner}."
      return 0
    fi
  done <<< "$pr_numbers"
  return 1
}

# Squash all commits on the PR branch into one and merge via GitHub.
# Must be called from inside the worktree (checkout_branch_worktree already ran).
# Usage: squash_and_merge_pr <pr_number> <pr_branch> <pr_title> <pr_body> <issue_number>
squash_and_merge_pr() {
  local pr_number="$1"
  local pr_branch="$2"
  local pr_title="$3"
  local pr_body="$4"
  local issue_number="$5"

  # Export git identity for ALL subprocesses (rebase, commit, amend).
  # Exporting here (not per-command) ensures git's internal re-invocations also
  # pick up the prauto identity rather than the system git config.
  export GIT_AUTHOR_NAME="$PRAUTO_GIT_AUTHOR_NAME"
  export GIT_AUTHOR_EMAIL="$PRAUTO_GIT_AUTHOR_EMAIL"
  export GIT_COMMITTER_NAME="$PRAUTO_GIT_AUTHOR_NAME"
  export GIT_COMMITTER_EMAIL="$PRAUTO_GIT_AUTHOR_EMAIL"

  # Step 1: Verify at least one commit is authored by this worker
  local authored_commits
  authored_commits=$(git log "origin/${PRAUTO_BASE_BRANCH}..HEAD" \
    --format="%ae" 2>/dev/null | grep -c "^${PRAUTO_GIT_AUTHOR_EMAIL}$" || true)
  if [[ "$authored_commits" -eq 0 ]]; then
    warn "PR #${pr_number}: no commits authored by ${PRAUTO_GIT_AUTHOR_EMAIL}. Skipping merge."
    return 1
  fi

  # Step 2: Fetch base branch
  git fetch origin "$PRAUTO_BASE_BRANCH" 2>/dev/null || {
    warn "PR #${pr_number}: git fetch failed."
    return 1
  }

  # Step 3: Rebase onto base branch
  if ! git rebase "origin/${PRAUTO_BASE_BRANCH}" 2>/dev/null; then
    warn "PR #${pr_number}: rebase onto origin/${PRAUTO_BASE_BRANCH} failed. Aborting."
    git rebase --abort 2>/dev/null || true
    return 1
  fi

  # Step 4: Find merge base
  local merge_base
  merge_base=$(git merge-base HEAD "origin/${PRAUTO_BASE_BRANCH}" 2>/dev/null) || {
    warn "PR #${pr_number}: could not find merge base."
    return 1
  }

  # Step 5: Count commits to squash
  local commit_count
  commit_count=$(git rev-list --count "${merge_base}..HEAD" 2>/dev/null || echo 0)

  # Step 6: Build commit message
  local msg_file
  msg_file=$(mktemp /tmp/prauto-squash-msg-XXXXXX)
  printf '%s\n\nCloses #%s\n' "$pr_title" "$issue_number" > "$msg_file"

  local author_arg="${PRAUTO_GIT_AUTHOR_NAME} <${PRAUTO_GIT_AUTHOR_EMAIL}>"

  # Step 7/8: Squash (amend if single commit, reset+commit if multiple)
  if [[ "$commit_count" -eq 1 ]]; then
    git commit --amend --author="$author_arg" --file="$msg_file" 2>/dev/null || {
      warn "PR #${pr_number}: git commit --amend failed."
      rm -f "$msg_file"
      return 1
    }
  else
    git reset --soft "$merge_base" 2>/dev/null || {
      warn "PR #${pr_number}: git reset --soft failed."
      rm -f "$msg_file"
      return 1
    }
    git commit --author="$author_arg" --file="$msg_file" 2>/dev/null || {
      warn "PR #${pr_number}: git commit (squash) failed."
      rm -f "$msg_file"
      return 1
    }
  fi
  rm -f "$msg_file"

  # Step 9: Force-push using GH_TOKEN explicitly so the push authenticates as the
  # prauto account rather than the system credential helper (which may be ep1804).
  local git_push_args=()
  if [[ -n "${GH_TOKEN:-}" ]]; then
    git_push_args+=("-c" "http.https://github.com/.extraHeader=Authorization: Bearer ${GH_TOKEN}")
  fi
  git "${git_push_args[@]}" push --force-with-lease origin "$pr_branch" 2>/dev/null || {
    warn "PR #${pr_number}: force-push failed (remote may have changed). Skipping merge."
    return 1
  }
  info "PR #${pr_number}: force-pushed squashed commit."

  # Step 10: Merge via gh CLI (uses GH_TOKEN exported by heartbeat.sh)
  if ! gh pr merge "$pr_number" -R "$PRAUTO_GITHUB_REPO" --merge --delete-branch 2>/dev/null; then
    warn "PR #${pr_number}: gh pr merge failed (CI checks may need to re-run after force push)."
  else
    info "PR #${pr_number}: merged and branch deleted."
  fi
}

# Reply to reviewer comments on a PR with idempotency.
# Usage: reply_to_comments <pr_number> <comment_ids_csv>
reply_to_comments() {
  local pr_number="$1"
  local comment_ids="$2"

  IFS=',' read -ra ids <<< "$comment_ids"
  for comment_id in "${ids[@]}"; do
    [[ -z "$comment_id" ]] && continue

    # Check if already in replied_comment_ids
    if [[ -f "$JOB_FILE" ]]; then
      local already_replied
      already_replied=$(jq -r --arg id "$comment_id" '.replied_comment_ids | index($id) // empty' "$JOB_FILE" 2>/dev/null)
      if [[ -n "$already_replied" ]]; then
        info "Comment ${comment_id} already replied to. Skipping."
        continue
      fi
    fi

    # Record ID before posting (crash safety)
    add_replied_comment_id "$comment_id"

    # Post reply
    gh api "repos/${PRAUTO_GITHUB_REPO}/pulls/${pr_number}/comments/${comment_id}/replies" \
      -f body="prauto(${PRAUTO_WORKER_ID}): Addressed feedback in latest commits." \
      2>/dev/null || warn "Failed to reply to comment ${comment_id} on PR #${pr_number}."
  done
}
