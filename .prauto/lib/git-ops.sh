# Git and PR lifecycle operations for prauto.
# Source this file — do not execute directly.
# Requires: helpers.sh sourced, config loaded, gh/git available.

# Create a new worktree on a fresh branch from the base.
# If the branch already exists (retry scenario), reuses it in a new worktree.
# Usage: create_branch <issue_number>
# Sets: BRANCH_NAME, WORKTREE_DIR
create_branch() {
  local issue_number="$1"
  BRANCH_NAME="${PRAUTO_BRANCH_PREFIX}I-${issue_number}"
  WORKTREE_DIR="${PRAUTO_DIR}/worktrees/I-${issue_number}"

  info "Fetching from origin..."
  git fetch origin 2>/dev/null || warn "git fetch failed — continuing with local refs."

  # Remove stale worktree from a previous attempt.
  if [[ -d "$WORKTREE_DIR" ]]; then
    warn "Removing stale worktree at ${WORKTREE_DIR}."
    git worktree remove --force "$WORKTREE_DIR" 2>/dev/null || rm -rf "$WORKTREE_DIR"
    git worktree prune 2>/dev/null || true
  fi

  if git show-ref --verify --quiet "refs/remotes/origin/${BRANCH_NAME}" ||
     git show-ref --verify --quiet "refs/heads/${BRANCH_NAME}"; then
    info "Branch ${BRANCH_NAME} already exists. Reusing in new worktree."
    git worktree add "$WORKTREE_DIR" "$BRANCH_NAME" 2>/dev/null ||
      error "Failed to create worktree for ${BRANCH_NAME}."
  else
    info "Creating branch ${BRANCH_NAME} from origin/${PRAUTO_BASE_BRANCH}..."
    git worktree add -b "$BRANCH_NAME" "$WORKTREE_DIR" "origin/${PRAUTO_BASE_BRANCH}" 2>/dev/null ||
      error "Failed to create worktree for new branch ${BRANCH_NAME}."
  fi

  info "Worktree ready at ${WORKTREE_DIR} (branch: ${BRANCH_NAME})."
}

# Create a worktree for an existing remote branch (resume or PR review).
# Usage: checkout_branch_worktree <branch_name>
# Sets: WORKTREE_DIR
checkout_branch_worktree() {
  local branch="$1"
  local safe_name="${branch//\//-}"
  WORKTREE_DIR="${PRAUTO_DIR}/worktrees/${safe_name}"

  info "Fetching origin/${branch}..."
  git fetch origin "$branch" 2>/dev/null || warn "git fetch failed for ${branch}."

  if [[ -d "$WORKTREE_DIR" ]]; then
    warn "Removing stale worktree at ${WORKTREE_DIR}."
    git worktree remove --force "$WORKTREE_DIR" 2>/dev/null || rm -rf "$WORKTREE_DIR"
    git worktree prune 2>/dev/null || true
  fi

  git worktree add "$WORKTREE_DIR" "$branch" 2>/dev/null ||
    error "Failed to create worktree for branch ${branch}."

  info "Worktree ready at ${WORKTREE_DIR} (branch: ${branch})."
}

# Push the current branch to origin.
push_branch() {
  local branch="$1"
  info "Pushing ${branch} to origin..."
  git push -u origin "$branch" 2>/dev/null || error "Failed to push ${branch} to origin."
  info "Pushed ${branch}."
}

# Create or update a PR for the given issue.
# Usage: create_or_update_pr <issue_number> <issue_title> <branch>
create_or_update_pr() {
  local issue_number="$1"
  local issue_title="$2"
  local branch="$3"

  # Check for existing PR
  local existing_pr
  existing_pr=$(gh pr list \
    -R "$PRAUTO_GITHUB_REPO" \
    --head "$branch" \
    --json number \
    --jq '.[0].number // empty' 2>/dev/null)

  if [[ -n "$existing_pr" ]]; then
    info "PR #${existing_pr} already exists for ${branch}. Adding update comment."
    local commit_log
    commit_log=$(git log --oneline "origin/${PRAUTO_BASE_BRANCH}..HEAD" 2>/dev/null || echo "(no commits)")
    gh pr comment "$existing_pr" -R "$PRAUTO_GITHUB_REPO" \
      --body "prauto(${PRAUTO_WORKER_ID}): Updated with new commits.

\`\`\`
${commit_log}
\`\`\`" 2>/dev/null || warn "Failed to comment on PR #${existing_pr}."
    return 0
  fi

  # Generate PR body
  local commit_log
  commit_log=$(git log --oneline "origin/${PRAUTO_BASE_BRANCH}..HEAD" 2>/dev/null || echo "(no commits)")

  local pr_body
  pr_body="## Summary

Automated implementation for #${issue_number}.
Generated by \`prauto(${PRAUTO_WORKER_ID})\` using Claude Code CLI.

## Changes

\`\`\`
${commit_log}
\`\`\`

## Test plan

- [ ] Review automated changes
- [ ] Verify tests pass in CI
- [ ] Check spec compliance

---
*Generated by prauto -- autonomous PR worker*"

  local repo_owner="${PRAUTO_GITHUB_REPO%%/*}"

  info "Creating PR for issue #${issue_number}..."
  gh pr create \
    -R "$PRAUTO_GITHUB_REPO" \
    --base "$PRAUTO_BASE_BRANCH" \
    --head "$branch" \
    --title "prauto: ${issue_title}" \
    --body "$pr_body" \
    --assignee "${PRAUTO_GITHUB_ACTOR}" \
    --reviewer "${repo_owner}" 2>/dev/null || error "Failed to create PR for ${branch}."

  info "PR created for issue #${issue_number}."
}

# Find open PRs with unaddressed reviewer comments.
# Sets: ACTIONABLE_PR_NUMBER, ACTIONABLE_PR_BRANCH, ACTIONABLE_PR_ISSUE, ACTIONABLE_COMMENTS
# Returns 0 if found, 1 if none.
find_actionable_prs() {
  local prs_json
  prs_json=$(gh pr list \
    -R "$PRAUTO_GITHUB_REPO" \
    --state open \
    --json number,headRefName,reviews \
    --limit 50 2>/dev/null) || {
    warn "Failed to list PRs."
    return 1
  }

  # Filter PRs on prauto branches
  local prauto_prs
  prauto_prs=$(echo "$prs_json" | jq -r --arg prefix "$PRAUTO_BRANCH_PREFIX" '
    [.[] | select(.headRefName | startswith($prefix))]
    | sort_by(.number)
  ')

  local pr_count
  pr_count=$(echo "$prauto_prs" | jq 'length')

  if [[ "$pr_count" -eq 0 ]]; then
    return 1
  fi

  # Check each PR for unaddressed reviewer comments
  local i=0
  while [[ "$i" -lt "$pr_count" ]]; do
    local pr_number
    pr_number=$(echo "$prauto_prs" | jq -r ".[$i].number")
    local pr_branch
    pr_branch=$(echo "$prauto_prs" | jq -r ".[$i].headRefName")

    # Get review comments (changes requested)
    local reviews
    reviews=$(gh pr view "$pr_number" -R "$PRAUTO_GITHUB_REPO" \
      --json reviews \
      --jq '[.reviews[] | select(.state == "CHANGES_REQUESTED" or .state == "COMMENTED")] | sort_by(.submittedAt) | last' \
      2>/dev/null)

    # Get PR comments to check for prauto replies
    local pr_comments
    pr_comments=$(gh api "repos/${PRAUTO_GITHUB_REPO}/pulls/${pr_number}/comments" \
      --jq '[.[] | {id: .id, body: .body, user: .user.login, created_at: .created_at}]' \
      2>/dev/null || echo "[]")

    # Find comments not yet addressed by prauto
    local unaddressed
    unaddressed=$(echo "$pr_comments" | jq -r --arg worker "prauto(${PRAUTO_WORKER_ID})" '
      [.[] | select(.body | startswith($worker) | not)]
    ')

    local unaddressed_count
    unaddressed_count=$(echo "$unaddressed" | jq 'length')

    if [[ "$unaddressed_count" -gt 0 ]] && [[ -n "$reviews" ]] && [[ "$reviews" != "null" ]]; then
      ACTIONABLE_PR_NUMBER="$pr_number"
      ACTIONABLE_PR_BRANCH="$pr_branch"
      # Extract issue number from branch name (prauto/I-42 → 42)
      ACTIONABLE_PR_ISSUE="${pr_branch#${PRAUTO_BRANCH_PREFIX}I-}"
      ACTIONABLE_COMMENTS=$(echo "$pr_comments" | jq -r --arg worker "prauto(${PRAUTO_WORKER_ID})" '
        [.[] | select(.body | startswith($worker) | not)]
        | map("Comment #\(.id) by \(.user):\n\(.body)")
        | join("\n\n---\n\n")
      ')
      info "Found actionable PR #${pr_number} with unaddressed comments."
      return 0
    fi

    i=$((i + 1))
  done

  return 1
}

# Reply to reviewer comments on a PR with idempotency.
# Usage: reply_to_comments <pr_number> <comment_ids_csv>
reply_to_comments() {
  local pr_number="$1"
  local comment_ids="$2"

  IFS=',' read -ra ids <<< "$comment_ids"
  for comment_id in "${ids[@]}"; do
    [[ -z "$comment_id" ]] && continue

    # Check if already in replied_comment_ids
    if [[ -f "$JOB_FILE" ]]; then
      local already_replied
      already_replied=$(jq -r --arg id "$comment_id" '.replied_comment_ids | index($id) // empty' "$JOB_FILE" 2>/dev/null)
      if [[ -n "$already_replied" ]]; then
        info "Comment ${comment_id} already replied to. Skipping."
        continue
      fi
    fi

    # Record ID before posting (crash safety)
    add_replied_comment_id "$comment_id"

    # Post reply
    gh api "repos/${PRAUTO_GITHUB_REPO}/pulls/${pr_number}/comments/${comment_id}/replies" \
      -f body="prauto(${PRAUTO_WORKER_ID}): Addressed feedback in latest commits." \
      2>/dev/null || warn "Failed to reply to comment ${comment_id} on PR #${pr_number}."
  done
}
